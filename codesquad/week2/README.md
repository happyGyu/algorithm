# Week2 Algorithm

# 필수 문제

## 1. Two-sum

- 아주 단순하게 풀었다. ( ~~'컴퓨터야 힘내! 나는 고민하고 싶지 않아!' 식 풀이.~~ )
1. 주어진 숫자 배열을 돌면서 Target을 맞출 수 있는 짝이 있는지 Array.indexOf 메서드로 살펴본다. 
2. 짝이 있고 그것이 나 자신이 아니면 답으로서 return 해주고 아니면 계속 진행.

- 위 풀이는 forEach와 indexOf를 동시에 사용하기 때문에 O(N<sup>2</sup>)이라고 생각한다.
배열에서 search하는 것이 아닌 key-value를 이용해 O(1)로 search하면 총 O(N)으로 해결할 수 있을 것 같은데 고민을 더 해봐야겠다. 

<hr>

## 7. Reverse-integer

- 이것 역시 고민보단 기본으로 제공하는 함수를 활용해서 풀었다. 
1. 주어진 숫자가 음수면 부호를 떼서 저장해준다. 
2. 배열에 담아 뒤집고 다시 숫자로 만든 뒤 저장한 부호를 붙여준다. (굳이 Number() 안해줘도 됨)
3. 문제에서 준 유효범위 안에 들어오는지 판단하고 return한다.

<hr>

## 83. Remove Duplicates from Sorted List

- 어제 공부하고 구현한건데! 의외로 헤매서 오래걸렸다.... 나중에 시간지나고 한번 더 풀어보자.
1. survived와 pointer 두개를 움직인다. survived는 head부터, pointer는 그 다음 노드부터 시작.
2. pointer를 한칸 씩 움직이면서 survived와 같은지 보고 같으면 연결을 끊고 다르면 survived를 업데이트 해주는 식으로 작동.

<br><br>

# 선택 문제

## 9. Palindrome Number

- 7번과 같은데 조건이 더 적음.

<hr>

## 14. Longest Common Prefix

- 가장 더럽게 구현한 것 같다.
1. 가장 짧은 단어를 찾아준다. (이 단어 길이만큼 반복문을 돌 것이다.)
2. 특정 인덱스의 한 글자를 기준으로 잡고 나머지 단어들을 돌면서 그 인덱스의 글자가 기준과 같은지 체크
3. 전부 같으면 prefix 업데이트, 다르면 거기서 종료.

- check, checker.... 마음에 안든다 O(N<sup>2</sup>)도 줄일 수 있으면 좋겠지만 뭔가 깔끔하게 짤 수 있는 방법을 생각해봐야겠다.

<hr>

## 141. Linked List Cycle

- 고민이 많았는데 가장 직관적인 방법을 택했다. Map 객체를 만들고 ssl을 돌면서 Map에 아직 없으면 저장하고 있으면 돌아왔다는 것이기 때문에 false를 반환한다.

- 찾아봤는데 Map은 haspMap 방식이 아니라 Map.has() 메서드가 O(1)이 아닌 O(logN)이라고 한다.
그럼에도 Object를 사용하지 않은 이유는 나는 key값이 string이 아닌 Node 자체가 되어야했기 때문이다. 

- 문제 follow up에서 특이하게 공간복잡도를 O(1)로 하는 방식을 생각해보라고 한다. 나는 지금 공간복잡도가 O(N)인 것 같은데 O(1)로 만들려면 포인터 몇개만 지정해서 그걸 가지고 list를 순회하며 찾는 방식으로 만들어야하지 않을까 싶다. 방법이 생각나면 업데이트 해야겠다. 