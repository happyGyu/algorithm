# ***Week1 Algorithm***

# BaekJoon 1009번
### 문제 해결과정 🔥

- 문제는 간단했다. a**b의 1의자리 수가 곧 답이기 때문이다(0일 경우에는 10번 컴퓨터).  
그러나 값의 범위가 (1 ≤ a < 100, 1 ≤ b < 1,000,000)로 크기 때문에 단순히 지수 계산을 하면 정수 표현 범위를 넘어갈 것이 분명했다.

- 따라서 반복되는 1의 자리 수의 규칙을 찾아 배열에 저장하는 방법을 택했다. 
- getAnswer 함수는 a를 거듭 곱해가며 1의 자리수를 배열에 저장한다.  
그러다 새롭게 계산된 1의 자리수가 배열의 첫 값과 일치하면 반복되는 숫자 loop가 끝난 것이므로 배열 만드는 과정을 마친다. 
- 원하는 값은 b번 거듭제곱했을 때의 1의자리 수이기 때문에 b를 '1의자리 수 규칙 배열'의 길이로 나눈 값이 index가 된다(정확히는 -1한 값).
- 0번 컴퓨터 대신 10번 컴퓨터로 결과값 출력을 조절해주면 문제 해결. 

### 고찰 🧐

- 마음에 들지 않는 부분이 있다.
```javascript
 const answerIdx = (b - 1) % repeating.length;
```
- '1의자리수 규칙 배열'에서 b번 만큼 반복한 값을 꺼내오기 위해서는 b % 배열.length를 한 후 배열 index이기 때문에 -1을 해주면 된다.  
그런데 자바스크립트의 경우 배열 인덱스 -1을 지원하지 않는다고 알고 있다....(python 좋아..)
그래서 논리적으로는 다소 이상하지만 b에서 1을 빼고 나눠주는 것으로 처리했다.  
(b가 1이상이므로 결과는 항상 갖게 나온다)

- 논리대로 코드를 짜려면 b % 배열.length - 1을 한 후 음수면(-1이면) 배열 끝 값으로 처리해주게 하면 되겠지만..... 솔직히 조금 귀찮았다..🤫


# BaekJoon 1076번
### 문제 해결과정 🔥
- 1009번보다 쉬웠다. 가장 먼저 든 생각은 색을 key로 값과 곱을 value로 갖는 Object, 또는 Map을 만들어 꺼내서 사용하면 되겠다 싶었다.

- 그런데 문제가 너무나도 친절하게 값은 index, 곱은 index만큼 10을 거듭제곱한 값이었다. 그래서 그냥 Array를 사용하였다.

# BaekJoon 1052번
### 문제 해결과정 🔥
- 지민이는 무한 리터의 물을 옮길 수 있는 괴력의 소유자지만 딱 k개만 들고 가고 싶어하는 고집쟁이다.
- 처음엔 문제 접근을 잘못했다. 남은 물병이 홀수면 새 것을 구매하면서 계속 짝을 맞춰야한다고 생각했는데 쉽게 반례를 찾아서 다행이었다.   
(ex. (65,2)면 0개 구매해도 됨.)
- 현재 가지고 있는 물통을 이용해 짝을 지어 만들 수 있는 최고 용량 물통을 계산했다. 
```javascript
function findMaximumPowerOfTwo(n) {
    let powerOfTwo = 1;
    while (n >= powerOfTwo * 2) {
        powerOfTwo *=2
    }
    return powerOfTwo
}
```
- 합쳐지지 않은 남은 물통들을 이용해 만들수 있는 최고 용량 물통을 계산하는 과정을 반복한다. 
- 게으른 지민이가 k개까지는 들고 갈수 있다고 k번 반복 후 남은 물통이 0개면 성공이다.
- 만약 k번 반복했는데도 물통이 남아있다면 필요한 만큼 물통을 구매해서 물통을 합쳐줘야한다. 
- '필요한 만큼'이란 지민이가 합친 물통 중 가장 작은 용량 물통을 하나 더 만들 수 있는 만큼을 이야기한다. (그러면 가장 작은 물통끼리 합쳐서 한단계 큰 물통 하나로 만들 수 있기 때문)

### 고찰 🧐
- 열심히 계산하다보니 결국 10진수를 2진법으로 변환하는 과정이랑 똑같다는 것을 알게되었다. 
- 문제를 보자마자 '아! 이건 2진법으로 바꿔야되겠구나!'라고 생각해내는 것은 현재 내 머리로는 쉽지 않은 일임을 알고 있기 때문에 아쉽진 않았다.
- 나중에 2진법을 활용하는 방식으로 코드를 고쳐보자.

# BaekJoon 10757번
### 문제 해결과정 🔥
- 보자마자 'bit fullAdder를 구현했던 것처럼 각 자리수를 가지고 sum, carry를 계산하면 되겠구나!'라는 생각은 들었다.
- 그런데 2진수로 변환하여 푸는 방법은 도저히 생각나지 않아 그냥 10진법 상태로 10진수 fullAdder를 구현했다.
- 로직은 2진수 fullAdder와 전혀 다르지 않기 때문에 쉽게 할 수 있었다.
- 2진수 변환을 이용하여 해결할 방법을 고민해보자(장점이 뭘까?)